#!/usr/bin/python

#################################################################
# gendeps.py - Generates dependency graph for inclusion in the Makefile.
#
# Execute this script when the dependencies have changed in order to rebuild
# recipes for inclusion in the master Makefile.
#
# Ensure that this script is executed regularly to keep the Makefile
# up-to-date.
#
# Include paths are given in gcc-syntax (-Ipath/to/include). These are the
# locations where this script will search for included files.
# The first non-option argument is the name of the variable for the source
# directory of modules.
# The second non-option argument is the source tree being scanned. Only files
# in this directory will be included in the recipes dep list, and this is
# by default included in the include paths.
# All other non-option arguments are the modules that dependency graphs are
# to be generated for; give the paths to their implementation files relative
# to the source directory
#
# Ex: ~$ ./gendeps.sh SDIR src -Icompat agent.cpp cmd.cpp event/dispatch.cpp
#
# All generated recipies will be of the following form:
#
# $(ODIR)/modulepath.o: $(srcvar)/modulepath $(srcdir)/dep1path $(srcdir)/dep2path ... $(srcdir)/depNpath
#	$(CXX) -c -o $@ $(srcvar)/modulepath $(CXXFLAGS)
#
# This script will only analyze double-quote includes; angle bracket includes
# are considered to be for external libraries and will be ignored.
#################################################################

import sys
import os.path
import re

def validate_args(args):
	srcvar_set = False
	module_set = False
	srcdir_set = False

	for n in args:
		if n[0] != "-":
			if srcvar_set:
				if srcdir_set:
					module_set = True
					break
				else:
					srcdir_set = True
			else:
				srcvar_set = True
	return srcvar_set and module_set and srcdir_set

def main():
	if not validate_args(sys.argv[1:]):
		sys.stderr.write("usage:  " + sys.argv[0] + " [options] srcvar srcdir mod1 [mod2 .. modN]\n")
	srcvar, srcdir, modules, include_paths, excluded_files, chomp_dirs = parse_args(sys.argv[1:])
	if srcvar is None:
		return 1
	reps = generate_recipes(srcvar, srcdir, modules, include_paths, excluded_files, chomp_dirs)
	print("###################################################")
	print("# Recipes auto-generated by gendeps.py script.    #")
	print("# These recipes should not be edited by hand; any #")
	print("# changes will be overwritten.                    #")
	print("###################################################")
	print("")
	for target, deps, steps in reps:
		deps_line = ' '.join(deps)
		print(target + ': ' + deps_line)
		for s in steps:
			print("\t" + s)
		print("")
	return 0
		
def generate_recipes(srcvar, srcdir, modules, include_paths, excluded_files, chomp_dirs=0):
	state = {'srcvar': srcvar, 'srcdir': srcdir, 'include_paths': include_paths, 'excludes': excluded_files}
	recipes = []
	reps = {}
	for mod in modules:
		target = mod.rsplit('.', 1)[0] + '.o'
		target_dir = os.path.dirname(target)
		target_file = os.path.basename(target)
		for n in range(chomp_dirs):
			target_dir = os.path.dirname(target_dir)
		target = os.path.join('$(ODIR)', target_dir, target_file)
		deps = scan_deps(state, os.path.join(srcdir, mod), mod, reports=reps)
		steps = ['$(CXX) -c -o $@ ' + os.path.join('$(' + srcvar + ')', mod) + ' $(CXXFLAGS)']
		recipes.append((target, deps, steps))
	return recipes
	
def parse_args(args):
	excluded_files = []
	include_paths = []
	modules = []
	srcvar = None
	srcdir = None
	chomp_dirs = 0
	bad_args = (None, None, None, None, None, None)
	for n in args:
		if n[0] == "-":
			if n[1] == "I":
				if len(n) < 3:
					sys.stderr.write("-I option must give path\n")
					return bad_args
				if os.path.isdir(n[2:]):
					if n[2:] not in include_paths:
						include_paths.append(n[2:])
				else:
					sys.stderr.write("skipping include path '" + n[2:] + "': not a readable dir\n")
			elif n[1] == 'E':
				if len(n) < 3:
					sys.stderr.write("-E option must give path to excluded file\n")
					return bad_args
				# the file might not exist but that is actually okay
				excluded_files.append(n[2:])
			elif n[1] == 'c':
				if len(n) < 3:
					sys.stderr.write("-c option must give number of dirs to chomp\n")
					return bad_args
				try:
					chomp_dirs = int(n[2])
				except ValueError:
					sys.stderr.write("chomp dirs option must be an integer\n")
					return bad_args
			else:
				sys.stderr.write("Unknown option '" + n + "'\n")
				return bad_args
		else:
			if srcvar is None:
				srcvar = n
			elif srcdir is None:
				if not os.path.isdir(n):
					sys.stderr.write("'" + n + "': not a directory. Abort.\n")
					return bad_args
				srcdir = n
				if n not in include_paths:
					include_paths.append(n)
			else:
				if os.path.isfile(os.path.join(srcdir, n)):
					modules.append(n)
				else:
					sys.stderr.write("skipping module '" + n + "' in '" + srcdir + "': not a readable file\n")
	if len(modules) < 1:
		sys.stderr.write("No valid modules given. Abort.\n")
		return bad_args
	return (srcvar, srcdir, modules, include_paths, excluded_files, chomp_dirs)
	
def find_includes(path):
	incs = []
	f = open(path, 'r')
	for line in f:
		m = re.search(r'^\s*#include\s+"([^"]+)"\s*$', line)
		if m:
			incs.append(m.group(1))
	f.close()
	return incs
	
def scan_deps(state, scan_file, dep_file, visited=None, reports=None):
	deps = []
	if reports is None:
		reports = {}
	if 'excluded' not in reports:
		reports['excluded'] = []
	if 'missed' not in reports:
		reports['missed'] = []
	if visited is None:
		visited = []
	if dep_file is not None:
		deps.append(os.path.join('$(' + state['srcvar'] + ')', dep_file))
	visited.append(scan_file)
	includes = find_includes(scan_file)
	for inc in includes:
		#search for the file in the include paths
		inc_file = None
		inc_dep = None
		inc_file, inc_dep = find_file(state['include_paths'], inc, scan_file, state['srcdir'])
		if inc_file is None:
			# only show the error message if we haven't yet done so:
			if (inc, scan_file) not in reports['missed']:
				sys.stderr.write("cannot locate file '" + inc + "' included from '" + scan_file + "'; skipping\n")
				reports['missed'].append((inc, scan_file))
		else:
			if inc_file not in visited:
				if inc_file in state['excludes']:
					# only show the error message if we haven't yet done so:
					if inc_file not in reports['excluded']:
						sys.stderr.write("file '" + inc_file + "' explicitly excluded; skipping\n")
						reports['excluded'].append(inc_file)
					visited.append(inc_file)
				else:
					deps += scan_deps(state, inc_file, inc_dep, visited, reports)
	return deps
	
def find_file(include_dirs, included_path, including_file, srcdir):
	inc_file = None
	inc_dep = None
	
	# also search in same directory as including file
	including_dir = os.path.dirname(including_file)
	
	for dir_path in include_dirs + [including_dir]:
		path = os.path.join(dir_path, included_path)
		if os.path.isfile(path):
			inc_file = path
			if dir_path == srcdir:
				inc_dep = included_path
	
	return (inc_file, inc_dep)

if __name__ == "__main__":
	status = main()
	sys.exit(status)

